---
title: "Analisi di una Rete di Interazioni Proteina-Proteina"
author: "Lara Vignotto"
output: html_document
# output: ioslides_presentation
#     css: ./style.css
#     # css: scrollable_slides.css
#     # incremental: yes
#   slidy_presentation: default
# # editor_options: 
# #   chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r warning=FALSE, error=FALSE, echo=F, show=F, include=F}
# library(graph)
library(igraph)
library(tidyr)
library(dplyr)
library(ggraph)
library(tidygraph)

myblue <- "#4b89bf" #"#5d95c6"
```


## Introduzione
Le reti di interazione proteina-proteina (protein-protein interaction networks, o PPNIs) rappresentano attraverso dei grafi i contatti fisici tra proteine in una cellula. Sono utilizzate per:

* differenziare la fisiologia cellulare tra stati normali e stati di malattia
* raffinare i passaggi di pathway (vie) metabolici
* riconoscere il ruolo di proteine non caratterizzate

Date le limitazioni delle tecniche di rilevamento di interazioni proteina-proteina, i dataset disponibili sono incompleti e "rumorosi".


## Dataset
Il [dataset](http://yfgdb.princeton.edu/cgi-bin/display.cgi?id=10688190&db=pmid) ([Uetz p., *et al.* (2000)](https://www.nature.com/articles/35001009)) si riferisce all'insieme proteine e interazioni tra esse all'interno di cellule di *S. cerevisiae*, o lievito di birra. È composto da 927 nodi (proteine) e 875 archi (interazioni).

* È vero che le PPNIs posseggono le proprietà tipiche delle reti "reali" (componente gigante, effetto *small world*, distribuzione dei gradi a coda lunga)?
* Qual è il significato biologico di tali proprietà? 
* Si possono apprezzare altre caratteristiche?


## Import del dataset
```{r, echo=FALSE}
# load dataset
file <- "http://yfgdb.princeton.edu/DBXREF/yfgdb/10688190id650/biogrid10688190id650.tab.txt"
yeast_interactome <- read.csv(file = file, 
                              header = FALSE,
                              sep = "\t",
                              col.names = c("INTERACTOR_A", "INTERACTOR_B", "OFFICIAL_SYMBOL_FOR_A", "OFFICIAL_SYMBOL_FOR_B", "ALIASES_FOR_A", "ALIASES_FOR_B", "EXPERIMENTAL_SYSTEM", "SOURCE", "PUBMED_ID", "ORGANISM_A_ID", "ORGANISM_B_ID"))
head(yeast_interactome)
```

```{r, echo=FALSE}
yeast_node_interactions <- yeast_interactome %>%
  select(INTERACTOR_A, INTERACTOR_B)
# summary(yeast_node_interactions)
```

```{r, echo=FALSE, fig.height = 10, fig.width = 14, fig.align = "center"}
yeast_graph <- as_tbl_graph(yeast_node_interactions, 
                            directed = FALSE)
# yeast_graph

# plot graph
set_graph_style(family = "sans")
ggraph(yeast_graph, 
       layout = "stress",
       # layout = "igraph",
       # algorithm = "nicely"
       ) +
  geom_edge_link(colour = "gray") +
  geom_node_point(colour = "black",
                  fill = myblue,
                  shape = 21,
                  size = 2)
```


## Componente gigante
```{r, echo=FALSE}
# select biggest subgraph
components <- clusters(yeast_graph, mode="weak")
biggest_cluster_id <- which.max(components$csize)
# ids
vert_ids <- V(yeast_graph)[components$membership == biggest_cluster_id]
# subgraph
yeast_graph2 <- subgraph(graph = yeast_graph, 
                         vids = vert_ids)
yeast_graph2 <- as_tbl_graph(yeast_graph2, 
                             directed = FALSE)
```

```{r, echo=FALSE, fig.height = 6, fig.width = 8, fig.align = "center"}
# plot graph
set_graph_style(family = "sans")
ggraph(yeast_graph2, 
       layout = "stress") +
  geom_edge_link(colour = "gray",
                 linejoin = "bevel") +
  geom_node_point(colour = "black",
                  fill = myblue,
                  shape = 21,
                  size = 1.8)
```

Numero di nodi della rete completa:
```{r, echo=FALSE}
gorder(yeast_graph)
```

Numero di nodi della componente gigante:
```{r, echo=FALSE}
gorder(yeast_graph2)
```

TODO: considerazioni


## Degree centrality
TODO: perché
```{r, echo=FALSE}
# calculate degrees of nodes
degree_centrality <- degree(yeast_graph2)
```

I nodi con maggiore e minore numero di vicini:
```{r, echo=FALSE}
# sort the degrees
head(sort(degree_centrality, decreasing = TRUE))
tail(sort(degree_centrality, decreasing = TRUE))
```

Il grado medio dei nodi è 
```{r, echo=FALSE}
# sort the degrees
mean(degree_centrality)
```

La distribuzione dei gradi nel grafo:
```{r, echo=FALSE, fig.align = "center"}
table(degree_centrality)
# hist(degree_centrality,
#      right = FALSE,
#      main = "Degree distribution",
#      xlab = "degree",
#      ylab = "frequency",
#      breaks = max(degree_centrality),
#      col = "gray")
# abline(v = mean(degree_centrality), 
#        col = myblue, 
#        lty = 3,
#        lwd = 3)
# legend(x = 13,
#        y = 195,
#        legend = c("average degree"),
#        col = c(myblue),
#        lty = 3,
#        lwd = 3)
```

Rappresentazione grafica:
```{r, echo=FALSE, fig.height = 8, fig.width = 10, fig.align = "center"}
# plot graph
set_graph_style(family = "sans")
yeast_graph2 %>%
  activate(nodes) %>%
  mutate(degree = centrality_degree()) %>%
  ggraph(layout = "stress") +
  geom_edge_link(colour = "gray",
                 linejoin = "bevel") +
  geom_node_point(aes(size = degree,
                      colour = degree)) +
  geom_node_label(aes(filter = degree>=10,
                      label = name),
                  size = 3,
                  show.legend = FALSE,
                  # colour = "white",
                  repel = TRUE,
                  force = 20,
                  force_pull = -20)
  # scale_size(range = c(1, 10))
```

Il nodo con grado maggiore è
```{r, echo=FALSE}
# top 3 nodes with highest degree centrality
head(sort(degree_centrality, decreasing = TRUE), 1)
```

e i suoi 21 vicini sono
```{r, echo=FALSE}
YML064C_adjacent <- adjacent_vertices(yeast_graph2, "YML064C")
YML064C_adjacent <- names(unlist(YML064C_adjacent)) %>%
  stringr::str_replace(pattern="YML064C.", replace="")
YML064C_adjacent
```

Ricercando su [FungiDB](https://fungidb.org/fungidb/app/record/gene/YML064C#CompoundsMetabolicPathways), troviamo che in letteratura le interazioni della proteina *YML064C* sono le seguenti
```{r, echo=FALSE}
file2 <- "datasets/fungidb_YML064C_interactions.txt"
YML064C_interactions_all <- read.csv(file = file2,
                                 header = TRUE,
                                 sep = "\t")
YML064C_interactions <- YML064C_interactions_all %>%
  select(Interacts.With) %>%
  as.list(YML064C_interactions)
YML064C_interactions <- unname(unlist(YML064C_interactions))
YML064C_interactions
```

Verifichiamo che i nodi del grafo adiacenti a *YML064C* siano corretti, ovvero che i nodi vicini trovati appaiano tra le interazioni indicate in letteratura:
```{r, echo=FALSE}
YML064C_adjacent %in% YML064C_interactions
```

Le funzioni cellulari delle proteine con grado maggiore sono:
```{r, echo=FALSE}
head(sort(degree_centrality, decreasing = TRUE), 3)
```

* [*YML064C*](https://www.yeastgenome.org/locus/S000004529): coinvolta nella terminazione della fase M della mitosi.
* [*YGL212W*](https://www.yeastgenome.org/locus/S000003180): fa parte del complesso SNARE, che permette l'aggancio dei vacuoli alle membrane cellulari.
* [*YDR328C*](https://www.yeastgenome.org/locus/S000002736): proteina evoluzionalmente conservata presente in vari complessi cellulari. Coinvolta nell'allineamento dei cromosomi lungo il fuso mitotico durante la divisione cellulare.

TODO: considerazioni


## Rete *scale-free*

La skewness della distribuzione dei gradi è:
```{r, echo=FALSE}
mean((degree_centrality - mean(degree_centrality))^3) / sd(degree_centrality)^3
```


La media e la mediana della distribuzione sono:
```{r, echo=FALSE}
summary(degree_centrality)
```


Istogramma della distribuzione dei gradi nel grafo:
```{r, echo=FALSE, fig.align = "center"}
hist(degree_centrality,
     right = FALSE,
     main = "Degree distribution",
     xlab = "degree",
     ylab = "frequency",
     breaks = max(degree_centrality),
     col = "white")
abline(v = mean(degree_centrality), 
       col = "darkgray", 
       lty = 2,
       lwd = 4)
abline(v = median(degree_centrality), 
       col = myblue, 
       lty = 2,
       lwd = 4)
legend(x = 13,
       y = 195,
       legend = c("mean", "median"),
       col = c("darkgray", myblue),
       lty = c(3,3),
       lwd = c(4,4))
```

Si può verificare che la distribuzione dei gradi dei nodi segue una legge di potenza graficando la distribuzione stessa in scala logaritmica su entrambi gli assi. 
```{r, echo=FALSE, fig.align = "center", warning=FALSE}
degree_dist_non_cumul <- degree_distribution(yeast_graph2,
                                             cumulative = FALSE)
plot(1:max(degree_centrality),
     degree_dist_non_cumul[-1],
     main = "Degree distribution (log, non-cumulative)",
     xlab = "degree",
     ylab = "probability",
     # type = "l",
     log = "xy")
# fit a power law distribution to the data
pow_law <- power.law.fit(degree_centrality)
lines(seq(degree_dist_non_cumul), 
      seq(degree_dist_non_cumul)^-(pow_law$alpha-1), 
      col = myblue,
      lwd = 2)
# fit a linear model to the data
keep <- degree_dist_non_cumul[-1] > 0
x <- (1:max(degree_centrality))[keep]
y <- degree_dist_non_cumul[-1][keep]
abline(lm(log(y)~log(x)),
       col = "darkgray",
       lwd = 2)
legend(x = 7,
       y = .5,
       legend = c("fitted power law", "fitted linear model"),
       col = c(myblue, "darkgray"),
       lwd = c(2, 2))
```

Adattando (*fitting*) una power law alla distribuzione, si ottiene una retta (blu) con *alfa* pari a:
```{r, echo=FALSE}
pow_law$alpha
```
Mentre, applicando una semplice regressione lineare sui dati, si ottiene un'altra retta (grigia) la cui intercetta è:
```{r, echo=FALSE}
coef( lm(log(y)~log(x)) )[2]
```

Funzione di distribuzione dei gradi, cumulativa:
```{r, echo=FALSE, fig.align = "center"}
degree_dist_cumul <- degree_distribution(yeast_graph2,
                                         cumulative = TRUE)
plot(1:max(degree_centrality),
     degree_dist_cumul[-1],
     main = "Degree distribution (log, cumulative)",
     xlab = "degree",
     ylab = "probability",
     type = "l",
     log = "xy",
     lwd = 1.5)
# lines(seq(degree_dist_cumul), 
#       seq(degree_dist_cumul)^-(pow_law$alpha-1), 
#       col = myblue,
#       lwd = 2)
# 
# x <- 1:max(degree_centrality)
# y <- degree_dist_cumul[-1]
# abline(lm(log(y)~log(x)))
# 
# legend(x = 8,
#        y = 1,
#        legend = c("fitted power law"),
#        col = c(myblue),
#        lwd = 2)
```
TODO: considerazioni


## Effetto *small world*

Numero di nodi del grafo:
```{r, echo=FALSE}
# number of nodes
vcount(yeast_graph2)
```

Distanza media:
```{r, echo=FALSE}
# mean distance
mean_distance(yeast_graph2)
```

Distanza massima:
```{r, echo=FALSE}
# max geodesic distance
diameter(yeast_graph2)
```

Grafici.
```{r, echo=FALSE, fig.height = 10, fig.width = 14, fig.align = "center"}
# plot
d <- get_diameter(yeast_graph2, directed=FALSE)
V(yeast_graph2)$color = "white"
E(yeast_graph2)$color = "grey"
E(yeast_graph2)$width = 1
E(yeast_graph2, path=d)$color = myblue
E(yeast_graph2, path=d)$width = 3
V(yeast_graph2)[d]$color = myblue

plot(yeast_graph2, 
     vertex.label = NA, 
     vertex.size=2)
```

```{r, echo=FALSE, fig.align = "center"}
# frequency
paths <- distance_table(yeast_graph2)$res
names(paths) <- 1:length(paths)

barplot(paths / sum(paths),
        main = "Distances histogram",
        xlab = "distance",
        ylab = "frequency")
abline(v = mean_distance(yeast_graph2),
       col = myblue,
       lty = 2,
       lwd = 5)
legend(x = 15,
       y = .15,
       legend = c("average distance"),
       col = c(myblue),
       lty = 2,
       lwd = 3)
```

TODO: considerazioni

